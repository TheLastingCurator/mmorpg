# Сетевой движок

## Требования

Технически игра должна суметь обслуживать столько же одновременно подключенных игроков, сколько было на пике у Eve Online, то есть 65 303.

Нужно сразу готовиться к масштабированию игры путем увеличения количества серверов ее обслуживающих.
Все должно быть устроено таким образом что на каждом сервере можно было обслуживать тысячи игроков.

В мморпг прокачка и урон должны происходить на сервере, а на клиенте должен только показываться интерфейс.

## Важно учитывать

Игровой сервер предполагается разворачивать на Raspberry Pi 4 с 4 гигабайтами RAM и безлимитным 1 гигабитным сетевым подключением.

В тестах Raspberry Pi 4 развивает скорость до 930Mbs, это 116,250,000 байт в секунду.

На каждого из 65 303 клиентов это 1780 байт в секунду. При пакет-лоссе 10% полезных данных остается 1602 байт/с.

Размеры заголовков: Ethernet - 14 байт, IP - 20 байт, TCP - 20 байт. Итого: 54 байта.

Клиенту необходимо отправлять хотя бы 5 обновлений мира в секунду, на обновление выходит 320 байт, из которых 266 полезной нагрузки.

При попытке отправлять клиенту 20 обновлений в секунду на обновление выйдет 80 байт, из которых 26 полезной нагрузки.

В 26 байт вполне можно уместить информацию о 2 персонажах из поля зрения в простом формате типа:

id персонажа = 2 байта, позиция = 4 байта, код действия = 2 байта, позиция действия = 4 байта, это позволит при 60 APM показывать все действия 40 персонажей в поле зрения.

## Представление состояния мира

Для хранения и передачи по сети состояний всего что может менять состояние в игре используется специальная структура данных:

Есть большой массив со всеми персонажами и активными монстрами, размер его заранее выбирается достаточно большим, чтобы не требовалось реаллокаций. В каждой ячейке кроме позиции и параметров персонажа хранится уникальный идентификатор персонажа, получаемый путем инкремента 64-битного счетчика при каждом создании нового персонажа. На персонажей таким образом можно хранить указатели, которые всегда указывают на валидную память в которой лежит либо тот самый персонаж на которого указатель указывал изначально, либо какой-то другой, который поместили в ту же ячейку после смерти старого. 

Для валидации указателей вместе с ними нужно хранить значение уникального идентификатора, если оно совпадает, персонаж точно тот самый, а если не совпадает - указатель протух. Для передачи по сети для каждого клиента заводится исходящий буфер, очередь отправки и массив битиков обозначающих присутствие в очереди соответствующего персонажа. Очередь организуется как циклический буфер достаточного размера чтобы туда уместились указатели на всех персонажей.

При изменении состояния персонажа, для каждого клиента проделываются следующие действия: в массиве битиков выставляется (если еще не была выставлена) единичка для этого персонажа. Если до этого там был нолик, то указатель на этого персонажа добавляется в очередь на отправку. Раз в кадр, если в буфере клиента есть свободное место, буфер заполняется данными о состоянии персонажей в порядке появления в очереди на отправку, и содержимое буфера отправляется по сети клиенту.

Таким образом при быстром изменении состояния одного персонажа, клиент с медленной сетью получает не последовательность состояний, а только одно свежее состояние.

В ходе работы не происходит ни одной аллокации или деаллокации, память не фрагментируется, обход памяти происходит в основном последовательно. Дальнейшие оптимизации: не ставить в очередь на отправку далекие и невидимые клиенту персонажи, не передавать мгновенные координаты, а использовать координаты начала и конца и моментах начала и конца движения, так что состояние начавшего двигаться из точки А в точку Б персонажа достаточно передать 1 раз, после чего персонаж на сервере и у всех клиентов будет двигаться синхронно до точки Б, где он и остановится.

Часто кликающих туда-сюда игроков и ИИ можно затроттлить, чтобы персонажи не меняли текущее действие чаще чем 4 раза в секунду.

## Лаг-компенсация на клиенте

Игрок кликает мышкой. Клиент игрока рисует визуальный отклик, чтобы игрок понимал, что его клик воспринят игрой. На сервер отправляется команда «иди туда». Сервер получает команду, например через 25 мс, и  применяет ее к персонажу игрока. В плане действий персонажа появляется новое состояние «персонаж в следующий кадр физики начнёт движение из той точки где он будет в следующий кадр физики в ту точку которую указал игрок». Следующий физический кадр отстоит от этого момента на 50 мс в будущее, то есть физика квантована по 20 кадров в секунду и считается вперёд на 1 кадр в будущее. Теперь у сервера есть данные о действиях игрока на 50 мс вперёд, сервер записывает последнее действие в состояние персонажа и оно синхронизируется по сети. Все игроки с хорошей сетью получают это состояние. У них 50 мс на то, чтобы успеть получить данные и нарисовать идеальную картинку. Клиент не обязан выкидывать предыдущие состояния персонажа, полученные по сети, клиенту не нужно быть высокоэффективным, поэтому клиент может хранить 2 последних состояния и использовать их для показа идеального мультика о движении персонажа.

Если же у клиента большой пинг, состояние дойдёт к нему поздно, скажем на 150 мс позже чем хотелось бы, за это время персонаж на клиенте может оказаться далеко от исходной точки движения описанной новым состоянием и ещё дальше от той точки в которой он должен быть к этому моменту при движении по заданной траектории. Тут начинает применяться клиентская компенсация лага. Персонаж начинает движение из той точки где он визуально находится и движется в ту точку где он должен был бы оказаться, но делает это быстрее чем должен по физике, чтобы за время порядка 250 мс оказаться в идеальной позиции и продолжить движение показывая идеальную картинку.


## Немного об отслеживании видимости

Передаются только смены состояний персонажей.
Персонаж был в состоянии "стоит в точке А" и в момент времени T1 игрок кликнул мышкой, отдавая команду "идти в точку Б",
сервер получает это и меняет состояние игрока на "с момента Т2 идет из точки А в точку Б".
После этого сервер отправляет информацию о состоянии этого персонажа всем кто находится достаточно близко чтобы увидеть этого персонажа.

Персонажи игры не смогут проходить друг сквозь друга или смотреть на далекие от себя участки мира, поэтому никакого смысла в отправке даже тысяче игроков состояния какого-либо одного персонажа нет.

> Нет, я понимаю, что Вы поставили цель создать баттлнек именно в аплинк, но это так не делается. Состояния мобов каких передавать? Опять же, все мобов мира всем игрокам онлайн слать?
Совершенно аналогично с персонажами игроков, только тем игрокам, которые могут увидеть соответствующих мобов.

Я понимаю, вы привыкли к наивной реализации, когда все персонажи хранятся в каком-нибудь листе и единственный способ получения близко находящихся персонажей - пройти по всем персонажам, посчитать расстояние или проверить на вхождение в AABB, и если делать так то конечно же даже при десяти тысячах персонажей даже пройти по всем столько раз сколько игроков онлайн можно только на очень мощном компьютере.

К счастью, есть огромное количество способов сделать все по-другому.

Для начала, рассмотрим примитивную оптимизацию, когда мир разбит на клеточки и на одной клеточке в один момент времени может находиться не более одного персонажа. В таком случае при наивном подходе мы создадим двухмерный массив идентификаторов персонажей размером с мир и для получения видимых персонажей будет достаточно проходить по всем видимым клеточкам (и возможно одной-двум дополнительным чтобы персонажи плавно входили и выходили из поля зрения).

Так, для diablo 1 размер видимой области составляет 11х11 клеток, итого 121 клетка. Полагаю, вы уже ликуете, ведь перебрать 121 клетку за 51 такт невозможно... но это и не нужно делать за 51 такт. Так как на передачу команды на сервер понадобилось как минимум 54 байта на заголовок, у нас только за счет заголовка есть 918 тактов процессора, а это дает нам аж 7 тактов на проверку наличия игрока в каждой клетке.

Но, конечно, мы не ограничимся наивной реализацией, ведь мы не хотим перебирать 121 клетку каждый раз когда игрок кликает мышкой.
Посмотрим на вторую примитивную оптимизацию, когда мы для каждого персонажа будем хранить список персонажей, которых он может видеть, и, соответственно, которые могут видеть его. Теперь рассылка информации о новом состоянии превращается в простой проход по списку тех, кому эту информацию нужно отправить, искать их вообще не нужно, они просто перечислены в списке.

Вы, конечно, возразите, что список взять негде, кроме как пройти по той же самой области. И это верно, первоначальный список можно составить именно таким способом. Но когда список уже есть, его нужно просто поддерживать в актуальном состоянии.

Итак, у нас есть список видимых персонажей, но часть персонажей за 1/20 секунды переместилась, некоторые из них могли выйти за пределы видимости, а другие могли наоборот начать друг друга видеть.

Пусть персонаж передвигается со скоростью 2 тайла в секунду, это означает, что за 1 игровой тик (1/20 секунды) персонаж может переместиться не дальше чем на 1 тайл, более того, если он переместился на 1 тайл, то он будет двигаться через этот тайл около 10 тиков.

Выходит, достаточно пройти по тайлам на границе видимой зоны и добавлять в список видимых друг другу персонажей, которые находятся ближе центра тайла и удалять из видимых персонажей которые находятся дальше центра тайла, при видимой зоне 11х11 граница составляет 11 тайлов в верхней линейке, 11 тайлов в нижней, 9 слева и 9 справа (9 а не 11 потому что самый верхний и самый нижний уже учли в верхней и нижней линейках), итого просмотреть нужно 40 тайлов. Нужно ли их просматривать каждй кадр? нет, ведь персонаж из центра тайла будет двигаться к его краю около 5 тиков, так что мы смело можем каждый кадр смотреть только на 1/4 из этих 40 тайлов, то есть всего на 10 тайлов.

Итак, каждый кадр мы смотрим на 10 тайлов для каждого персонажа игрока, при 65 303 персонажах это 653 030 тайлов за кадр, а так как кадров 20, то за секунду мы просматриваем 13060600 тайлов, если просмотр одного тайла будет занимать даже целых 10 наносекунд, на все уйдет 0.13 секунды процессора, а у нас этих секунд целых 4.

Но, конечно же, возникает вопрос, а действительно ли так эффективно проходить по 10 тайлам для каждого персонажа игрока каждый тик? Может быть можно это как-то оптимизировать? И, конечно же, для неплотно стоящей толпы персонажей, нет никакой необходимости проходить по такому большому количеству тайлов, можно использовать тайлы большего размера (назовем их супертайлы), каждый из которых может хранить например связный список или массив стоящих на нем персонажей. Так, если мы увеличим линейный размер в 2 раза, то и проходить нам нужно будет не по 10 а по 5 тайлам, и на это уйдет 0.065 секунды процессорного времени в секунду. В плотной толпе, однако, эта оптимизация превратится в пессимизацию, так как придется рассматривать в 2 раза больше персонажей стоящих на границе видимости, но действительно ли нужно оптимизировать игру под случай, когда игроки набились как сардины в банке и по сути даже перемещатья не могут, так как все клетки вокруг заняты? Полагаю, оптимизировать такой случай не требуется, случайно игроки так не встанут, а если они сделают это специально, то сервер как-нибудь переживет лишние 3% нагрузки.

Ну вот, мы даже еще не начали всерьез оптимизировать, никаких крутых битовых карт и масок не применили, а уже ничего не ищем по клику, в памяти поддерживается всегда актуальный список видимых персонажей и на это тратится всего несколько процентов производительности процессора.
## Основные технические характеристики 

Игровой мир будет бесшовным, размер карты 8 км х 8 км, в мире будет всего 262144 персонажей, из которых половина может управляться игроками, а вторая половина - ИИ.

Мир разделяется на шарды по географическому принципу, при этом динамически меняя границы раздела для того, чтобы особо крупные скопления игроков не перегружали отдельные локации.

